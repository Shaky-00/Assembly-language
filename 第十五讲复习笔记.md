### 第十五讲 X86系统启动代码及安全攻击

#### 一、X86系统启动过程

**BIOS**

POST（Power on self test，上电自检）

初始化硬件设备 - PCI设备

搜索一个操作系统来启动 - 软盘、硬盘、CD-ROM的第一个扇区（引导扇区）

把找到的有效设备的第一个扇区（引导扇区）的内容拷贝到物理地址0x00007c00的内存空间，跳转到该地址执行

**引导装入程序**

相当于一个小型OS，支持多种磁盘文件系统，支持Multiboot-OS

引导装入程序的初始化代码与操作系统的初始化代码功能基本上是相似的

**OS初始化代码**

第一个扇区代码（引导扇区，bootsect）

	- 实模式的工作模式
	- 拷贝后续的启动代码（setup）

启动代码

	- 从实模式切换到保护模式
	- 在保护模式下完成后续代码的准备
	- 转入后续代码的执行

#### 二、相关知识

**实地址模式线性地址的计算**

线性地址 = 段地址 * 16 + 偏移量

> 如08F1:0100 = 08F10 + 0100 = 09010

**IO地址空间**

独立的64K地址空间（IO PORT）

​	0x0000 - 0xFFFF

IO PORT用于访问硬件设备

**BIOS调用**

Int 0x10：VGA显示

Int 0x13：磁盘读写

#### 三、系统引导扇区代码解析

#### 四、实模式中断处理程序

**IRET - Interrupu Return指令**

指令格式（Intel）

```assembly
IRET
```

从终端处理程序返回被中断的程序（POP eip, cs, eflags）

**实模式中断向量表IDT**

- IDT基址缺省位于物理地址0x0
- 共256个中断向量
- 每个中断向量占用4字节
  - 高2个字节是中断处理程序的段基址
  - 低2个字节时中断处理程序的段内偏移
  - 256个中断向量占据0x0-0x3ff的内存空间
- 可用LIDT改变中断向量表基址

一般的中断处理程序：

```assembly
IntHandler:
	# 保存寄存器
	# 中断处理程序主体
	# 恢复寄存器
	iret
```

代码实例 - 将输入的字符串小写字母替换成大写字母

Input: DS:SI输入字符串的地址	Output: 无

```assembly
IntHandler:
	pushw	%ax
1:
	movb	(%si), %al
	test	%al, %al
	jz 		1f
	subb	$'a', %al
	jae		2f
	addb	$0x41, %al
	movb 	%al, (%si)
2:
	inc 	%si
	jmp		1b
1:
	popw	%ax
	iret
```

#### 五、Bootsect.S（U盘读）

#### 六、安全与攻击简介

**缓冲区溢出**

数据读写拷贝时：写入数据大小超过目标缓冲区大小；读出的数据大小超过源缓冲区的大小

侧信道攻击

Cache side-channel attack

- 通过间接的手段获得Cache的内容或通过Cache获得限制访问的地址内容
- 利用Cache带来的访问时间差异，通过测量某数据的访问时间，判断其是否在Cache中